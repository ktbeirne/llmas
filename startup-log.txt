
> llmdesktopmascot@1.0.0 start
> electron-forge start

❯ Checking your system
❯ Checking package manager version
✔ Found npm@11.3.0
✔ Checking your system
[?25h❯ Locating application
✔ Locating application
❯ Loading configuration
✔ Loading configuration
❯ Preparing native dependencies
✔ Preparing native dependencies
❯ Running generateAssets hook
✔ Running generateAssets hook
❯ Running preStart hook
❯ [plugin-vite] Preparing vite bundles
❯ Launching dev servers for renderer process code
WebSocket server error: Port 3001 is already in use
13:42:05 [vite] (client) Pre-transform error: Transform failed with 1 error:
/Users/hirose/dev/mascot/src/renderer/components/common/FormField.test.tsx:33:40: ERROR: Syntax error "n"
  Plugin: vite:esbuild
  File: /Users/hirose/dev/mascot/src/renderer/components/common/FormField.test.tsx:33:40
  
  Syntax error "n"
  31 |  ];
  32 |  
  33 |  describe('FormField Component', () => {\n  describe('基本的なレンダリング', () => {\n    it('デフォルトのpropsで正常にレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"input\" \n          label=\"テストフィールド\"\n          data-testid=\"default-field\" \n        />\n      );\n      \n      expect(screen.getByTestId('default-field')).toBeInTheDocument();\n      expect(screen.getByText('テストフィールド')).toBeInTheDocument();\n      expect(screen.getByTestId('default-field-field')).toBeInTheDocument();\n    });\n\n    it('カスタムchildrenが正しく表示される', () => {\n      render(\n        <FormField \n          label=\"カスタムフィールド\"\n          data-testid=\"custom-field\"\n        >\n          <div data-testid=\"custom-content\">カスタムコンテンツ</div>\n        </FormField>\n      );\n      \n      expect(screen.getByTestId('custom-content')).toBeInTheDocument();\n      expect(screen.getByText('カスタムコンテンツ')).toBeInTheDocument();\n    });\n  });\n\n  describe('フィールドタイプ', () => {\n    it('type=\"input\"で入力フィールドがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"入力フィールド\"\n          inputProps={{ placeholder: 'テキストを入力' }}\n          data-testid=\"input-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('input-field-field');\n      expect(input).toBeInTheDocument();\n      expect(input).toHaveAttribute('type', 'text');\n      expect(input).toHaveAttribute('placeholder', 'テキストを入力');\n    });\n\n    it('type=\"select\"で選択フィールドがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"select\"\n          label=\"選択フィールド\"\n          selectProps={{ options: testSelectOptions, placeholder: '選択してください' }}\n          data-testid=\"select-field\"\n        />\n      );\n      \n      const select = screen.getByTestId('select-field-field');\n      expect(select).toBeInTheDocument();\n      expect(select).toHaveAttribute('role', 'combobox');\n      expect(screen.getByText('選択してください')).toBeInTheDocument();\n    });\n\n    it('type=\"textarea\"でテキストエリアがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"textarea\"\n          label=\"テキストエリア\"\n          textareaProps={{ placeholder: '詳細を入力', rows: 4 }}\n          data-testid=\"textarea-field\"\n        />\n      );\n      \n      const textarea = screen.getByTestId('textarea-field-field');\n      expect(textarea).toBeInTheDocument();\n      expect(textarea.tagName).toBe('TEXTAREA');\n      expect(textarea).toHaveAttribute('placeholder', '詳細を入力');\n      expect(textarea).toHaveAttribute('rows', '4');\n    });\n\n    it('type=\"checkbox\"でチェックボックスがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"チェックボックス\"\n          checkboxProps={{ value: 'check1' }}\n          data-testid=\"checkbox-field\"\n        />\n      );\n      \n      const checkbox = screen.getByTestId('checkbox-field-field');\n      expect(checkbox).toBeInTheDocument();\n      expect(checkbox).toHaveAttribute('type', 'checkbox');\n      expect(checkbox).toHaveAttribute('value', 'check1');\n      \n      // チェックボックスの場合、ラベルは横に表示される\n      const label = screen.getByText('チェックボックス');\n      expect(label).toBeInTheDocument();\n    });\n\n    it('type=\"radio\"でラジオボタンがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"radio\"\n          label=\"ラジオボタン\"\n          options={testRadioOptions}\n          radioProps={{ name: 'test-radio' }}\n          data-testid=\"radio-field\"\n        />\n      );\n      \n      // 各ラジオオプションが表示される\n      testRadioOptions.forEach(option => {\n        expect(screen.getByText(option.label)).toBeInTheDocument();\n      });\n      \n      // 無効なオプションが正しく無効化される\n      const radioInputs = screen.getAllByRole('radio');\n      expect(radioInputs).toHaveLength(3);\n      expect(radioInputs[2]).toBeDisabled(); // 3番目のオプションは無効\n    });\n\n    it('type=\"button\"でボタンがレンダリングされる', () => {\n      const handleClick = vi.fn();\n      \n      render(\n        <FormField \n          type=\"button\"\n          label=\"送信\"\n          buttonProps={{ variant: 'primary', onClick: handleClick }}\n          data-testid=\"button-field\"\n        />\n      );\n      \n      const button = screen.getByRole('button', { name: '送信' });\n      expect(button).toBeInTheDocument();\n      expect(button).toHaveTextContent('送信');\n    });\n  });\n\n  describe('レイアウト', () => {\n    const layouts: FormFieldLayout[] = ['vertical', 'horizontal', 'inline'];\n\n    layouts.forEach(layout => {\n      it(`layout=\"${layout}\" が正しく適用される`, () => {\n        render(\n          <FormField \n            type=\"input\"\n            label=\"レイアウトテスト\"\n            layout={layout}\n            data-testid={`${layout}-field`}\n          />\n        );\n        \n        const field = screen.getByTestId(`${layout}-field`);\n        expect(field).toBeInTheDocument();\n        \n        if (layout === 'vertical') {\n          expect(field.className).toContain('flex-col');\n        } else if (layout === 'horizontal') {\n          expect(field.className).toContain('flex');\n          expect(field.className).toContain('items-start');\n        } else if (layout === 'inline') {\n          expect(field.className).toContain('flex');\n          expect(field.className).toContain('items-center');\n        }\n      });\n    });\n\n    it('horizontalレイアウトでlabelWidthが適用される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"ラベル幅テスト\"\n          layout=\"horizontal\"\n          labelWidth=\"200px\"\n          data-testid=\"label-width-field\"\n        />\n      );\n      \n      const label = screen.getByText('ラベル幅テスト');\n      expect(label).toHaveStyle({ width: '200px' });\n    });\n  });\n\n  describe('サイズ', () => {\n    const sizes: FormFieldSize[] = ['sm', 'md', 'lg'];\n\n    sizes.forEach(size => {\n      it(`size=\"${size}\" が正しく適用される`, () => {\n        render(\n          <FormField \n            type=\"input\"\n            label=\"サイズテスト\"\n            size={size}\n            data-testid={`${size}-size-field`}\n          />\n        );\n        \n        const input = screen.getByTestId(`${size}-size-field-field`);\n        expect(input).toBeInTheDocument();\n        \n        if (size === 'sm') {\n          expect(input.className).toContain('text-xs');\n        } else if (size === 'lg') {\n          expect(input.className).toContain('text-base');\n        }\n      });\n    });\n  });\n\n  describe('必須フィールド', () => {\n    it('required=trueで必須マークが表示される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"必須フィールド\"\n          required\n          data-testid=\"required-field\"\n        />\n      );\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n      expect(requiredMark).toHaveTextContent('*');\n    });\n\n    it('チェックボックスで必須マークが正しく表示される', () => {\n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"必須チェック\"\n          required\n          data-testid=\"required-checkbox\"\n        />\n      );\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n    });\n  });\n\n  describe('エラーメッセージ', () => {\n    it('エラーメッセージが正しく表示される', () => {\n      const errorMessage = 'このフィールドは必須です';\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーフィールド\"\n          error={errorMessage}\n          data-testid=\"error-field\"\n        />\n      );\n      \n      const errorElement = screen.getByTestId('error-field-error');\n      expect(errorElement).toBeInTheDocument();\n      expect(errorElement).toHaveTextContent(errorMessage);\n      expect(errorElement).toHaveAttribute('role', 'alert');\n    });\n\n    it('エラーがある場合はヘルプテキストは表示されない', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーヘルプテスト\"\n          error=\"エラーメッセージ\"\n          helpText=\"ヘルプテキスト\"\n          data-testid=\"error-help-field\"\n        />\n      );\n      \n      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();\n      expect(screen.queryByText('ヘルプテキスト')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('ヘルプテキスト', () => {\n    it('ヘルプテキストが正しく表示される', () => {\n      const helpText = '半角英数字で入力してください';\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"ヘルプフィールド\"\n          helpText={helpText}\n          data-testid=\"help-field\"\n        />\n      );\n      \n      const helpElement = screen.getByTestId('help-field-help');\n      expect(helpElement).toBeInTheDocument();\n      expect(helpElement).toHaveTextContent(helpText);\n    });\n  });\n\n  describe('disabled状態', () => {\n    it('disabled=trueでフィールドが無効化される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"無効フィールド\"\n          disabled\n          data-testid=\"disabled-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('disabled-field-field');\n      expect(input).toBeDisabled();\n    });\n\n    it('ラジオボタンで個別とグローバルの無効化が正しく動作する', () => {\n      render(\n        <FormField \n          type=\"radio\"\n          label=\"無効ラジオ\"\n          options={testRadioOptions}\n          disabled\n          data-testid=\"disabled-radio\"\n        />\n      );\n      \n      const radioInputs = screen.getAllByRole('radio');\n      radioInputs.forEach(radio => {\n        expect(radio).toBeDisabled();\n      });\n    });\n  });\n\n  describe('fullWidth', () => {\n    it('fullWidth=falseで幅が制限される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"幅制限フィールド\"\n          fullWidth={false}\n          data-testid=\"limited-width-field\"\n        />\n      );\n      \n      const field = screen.getByTestId('limited-width-field');\n      expect(field.className).toContain('w-auto');\n    });\n  });\n\n  describe('イベントハンドリング', () => {\n    it('入力フィールドでイベントが正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"イベントテスト\"\n          inputProps={{ onChange: handleChange }}\n          data-testid=\"event-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('event-field-field');\n      await user.type(input, 'テスト');\n      \n      expect(handleChange).toHaveBeenCalled();\n    });\n\n    it('チェックボックスでイベントが正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"チェックイベント\"\n          checkboxProps={{ onChange: handleChange }}\n          data-testid=\"checkbox-event\"\n        />\n      );\n      \n      const checkbox = screen.getByTestId('checkbox-event-field');\n      await user.click(checkbox);\n      \n      expect(handleChange).toHaveBeenCalled();\n    });\n\n    it('ボタンでイベントが正しく動作する', async () => {\n      const handleClick = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"button\"\n          label=\"クリック\"\n          buttonProps={{ onClick: handleClick }}\n          data-testid=\"button-event\"\n        />\n      );\n      \n      const button = screen.getByRole('button', { name: 'クリック' });\n      await user.click(button);\n      \n      expect(handleClick).toHaveBeenCalled();\n    });\n  });\n\n  describe('アクセシビリティ', () => {\n    it('ラベルとフィールドが正しく関連付けられる', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"アクセシブルフィールド\"\n          data-testid=\"accessible-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('accessible-field-field');\n      const label = screen.getByText('アクセシブルフィールド');\n      \n      expect(label).toHaveAttribute('for', input.id);\n    });\n\n    it('エラー状態でaria属性が正しく設定される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーアクセシビリティ\"\n          error=\"エラーです\"\n          data-testid=\"error-a11y-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('error-a11y-field-field');\n      expect(input).toHaveAttribute('aria-invalid', 'true');\n    });\n  });\n\n  describe('カスタマイズ', () => {\n    it('カスタムクラスが正しく適用される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"カスタムクラス\"\n          className=\"custom-field\"\n          labelClassName=\"custom-label\"\n          fieldClassName=\"custom-field-container\"\n          errorClassName=\"custom-error\"\n          helpClassName=\"custom-help\"\n          error=\"エラー\"\n          helpText=\"ヘルプ\"\n          data-testid=\"custom-classes\"\n        />\n      );\n      \n      const field = screen.getByTestId('custom-classes');\n      expect(field.className).toContain('custom-field');\n      \n      const label = screen.getByText('カスタムクラス');\n      expect(label.className).toContain('custom-label');\n    });\n  });\n\n  describe('型安全性', () => {\n    it('FormFieldPropsの型が正しく適用される', () => {\n      // 型チェックのみ（実行時エラーがないことを確認）\n      const formFieldProps: FormFieldProps = {\n        type: 'input',\n        label: 'タイプセーフフィールド',\n        layout: 'horizontal',\n        size: 'lg',\n        required: true,\n        fullWidth: false,\n        inputProps: {\n          type: 'email',\n          placeholder: 'example@domain.com'\n        },\n        'data-testid': 'type-safe-field'\n      };\n      \n      render(<FormField {...formFieldProps} />);\n      \n      expect(screen.getByTestId('type-safe-field')).toBeInTheDocument();\n    });\n  });\n});"
     |                                          ^
  
13:42:05 [vite] (client) Pre-transform error: Transform failed with 1 error:
/Users/hirose/dev/mascot/src/renderer/components/common/Select.test.tsx:6:4: ERROR: Syntax error "n"
  Plugin: vite:esbuild
  File: /Users/hirose/dev/mascot/src/renderer/components/common/Select.test.tsx:6:4
  
  Syntax error "n"
  4  |   * Phase 3.5.2.1 Task 3: Selectコンポーネントテスト
  5  |   * TypeScript厳密型定義、アクセシビリティ、ドロップダウン機能のテスト
  6  |   */\n\nimport React from 'react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n// テスト対象\nimport Select, { type SelectProps, type SelectOption, type SelectSize, type SelectVariant } from './Select';\n\n// テスト用のオプションデータ\nconst testOptions: SelectOption[] = [\n  { value: 'option1', label: 'オプション1' },\n  { value: 'option2', label: 'オプション2', description: '説明2' },\n  { value: 'option3', label: 'オプション3', disabled: true },\n  { value: 'option4', label: 'オプション4', description: '説明4' },\n];\n\n// テスト用のアイコン付きオプション\nconst TestIcon: React.FC = () => (\n  <svg data-testid=\"test-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n    <circle cx=\"8\" cy=\"8\" r=\"4\" />\n  </svg>\n);\n\nconst testOptionsWithIcons: SelectOption[] = [\n  { value: 'icon1', label: 'アイコン1', icon: <TestIcon /> },\n  { value: 'icon2', label: 'アイコン2', icon: <TestIcon /> },\n];\n\ndescribe('Select Component', () => {\n  describe('基本的なレンダリング', () => {\n    it('デフォルトのpropsで正常にレンダリングされる', () => {\n      render(<Select options={testOptions} data-testid=\"default-select\" />);\n      \n      const select = screen.getByTestId('default-select');\n      expect(select).toBeInTheDocument();\n      expect(select).toHaveAttribute('role', 'combobox');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n\n    it('プレースホルダーが正しく表示される', () => {\n      const placeholder = 'カスタムプレースホルダー';\n      render(<Select options={testOptions} placeholder={placeholder} data-testid=\"placeholder-select\" />);\n      \n      expect(screen.getByText(placeholder)).toBeInTheDocument();\n    });\n\n    it('デフォルト値が正しく設定される', () => {\n      render(\n        <Select \n          options={testOptions} \n          defaultValue=\"option2\" \n          data-testid=\"default-value-select\" \n        />\n      );\n      \n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n    });\n  });\n\n  describe('サイズ（size）', () => {\n    const sizes: SelectSize[] = ['sm', 'md', 'lg'];\n\n    sizes.forEach(size => {\n      it(`size=\"${size}\" が正しく適用される`, () => {\n        render(<Select options={testOptions} size={size} data-testid={`${size}-select`} />);\n        \n        const select = screen.getByTestId(`${size}-select`);\n        expect(select).toBeInTheDocument();\n        \n        if (size === 'sm') {\n          expect(select.className).toContain('text-xs');\n        } else if (size === 'lg') {\n          expect(select.className).toContain('text-base');\n        }\n      });\n    });\n  });\n\n  describe('バリアント（variant）', () => {\n    const variants: SelectVariant[] = ['default', 'error', 'success'];\n\n    variants.forEach(variant => {\n      it(`variant=\"${variant}\" が正しく適用される`, () => {\n        render(<Select options={testOptions} variant={variant} data-testid={`${variant}-select`} />);\n        \n        const select = screen.getByTestId(`${variant}-select`);\n        expect(select).toBeInTheDocument();\n        \n        if (variant === 'error') {\n          expect(select.className).toContain('border-red-500');\n          expect(select).toHaveAttribute('aria-invalid', 'true');\n        } else if (variant === 'success') {\n          expect(select.className).toContain('border-green-500');\n        }\n      });\n    });\n  });\n\n  describe('ラベル', () => {\n    it('ラベルが正しく表示される', () => {\n      const label = 'セレクトラベル';\n      render(<Select options={testOptions} label={label} data-testid=\"labeled-select\" />);\n      \n      const labelElement = screen.getByText(label);\n      const select = screen.getByTestId('labeled-select');\n      \n      expect(labelElement).toBeInTheDocument();\n      expect(labelElement).toHaveAttribute('for', select.id);\n    });\n\n    it('required=trueで必須マークが表示される', () => {\n      render(<Select options={testOptions} label=\"必須セレクト\" required data-testid=\"required-select\" />);\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n      expect(requiredMark).toHaveTextContent('*');\n    });\n  });\n\n  describe('エラーメッセージ', () => {\n    it('エラーメッセージが正しく表示される', () => {\n      const errorMessage = '選択が必要です';\n      render(<Select options={testOptions} error={errorMessage} data-testid=\"error-select\" />);\n      \n      const select = screen.getByTestId('error-select');\n      const errorElement = screen.getByTestId('error-select-error');\n      \n      expect(errorElement).toBeInTheDocument();\n      expect(errorElement).toHaveTextContent(errorMessage);\n      expect(errorElement).toHaveAttribute('role', 'alert');\n      expect(select).toHaveAttribute('aria-invalid', 'true');\n    });\n\n    it('エラーがある場合はvariantがerrorに変更される', () => {\n      render(<Select options={testOptions} variant=\"success\" error=\"エラーです\" data-testid=\"error-override\" />);\n      \n      const select = screen.getByTestId('error-override');\n      expect(select.className).toContain('border-red-500');\n    });\n  });\n\n  describe('ヘルプテキスト', () => {\n    it('ヘルプテキストが正しく表示される', () => {\n      const helpText = '選択してください';\n      render(<Select options={testOptions} helpText={helpText} data-testid=\"help-select\" />);\n      \n      const helpElement = screen.getByTestId('help-select-help');\n      expect(helpElement).toBeInTheDocument();\n      expect(helpElement).toHaveTextContent(helpText);\n    });\n\n    it('エラーがある場合はヘルプテキストは表示されない', () => {\n      render(\n        <Select \n          options={testOptions}\n          helpText=\"ヘルプテキスト\" \n          error=\"エラーメッセージ\" \n          data-testid=\"error-help-select\"\n        />\n      );\n      \n      expect(screen.queryByText('ヘルプテキスト')).not.toBeInTheDocument();\n      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();\n    });\n  });\n\n  describe('ドロップダウン操作', () => {\n    it('クリックでドロップダウンが開く', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"dropdown-select\" />);\n      \n      const select = screen.getByTestId('dropdown-select');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n      \n      await user.click(select);\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n      expect(screen.getByRole('listbox')).toBeInTheDocument();\n    });\n\n    it('オプションが正しく表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"options-select\" />);\n      \n      await user.click(screen.getByTestId('options-select'));\n      \n      testOptions.forEach(option => {\n        expect(screen.getByText(option.label)).toBeInTheDocument();\n      });\n    });\n\n    it('オプション選択が正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptions} onChange={handleChange} data-testid=\"select-option\" />);\n      \n      await user.click(screen.getByTestId('select-option'));\n      await user.click(screen.getByText('オプション2'));\n      \n      expect(handleChange).toHaveBeenCalledWith('option2', testOptions[1]);\n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n    });\n\n    it('無効なオプションは選択できない', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptions} onChange={handleChange} data-testid=\"disabled-option\" />);\n      \n      await user.click(screen.getByTestId('disabled-option'));\n      await user.click(screen.getByText('オプション3'));\n      \n      expect(handleChange).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('キーボードナビゲーション', () => {\n    it('Enterキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"keyboard-select\" />);\n      \n      const select = screen.getByTestId('keyboard-select');\n      fireEvent.keyDown(select, { key: 'Enter' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('Spaceキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"space-select\" />);\n      \n      const select = screen.getByTestId('space-select');\n      fireEvent.keyDown(select, { key: ' ' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('Escapeキーでドロップダウンが閉じる', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"escape-select\" />);\n      \n      const select = screen.getByTestId('escape-select');\n      await user.click(select);\n      expect(select).toHaveAttribute('aria-expanded', 'true');\n      \n      fireEvent.keyDown(select, { key: 'Escape' });\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n\n    it('ArrowDownキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"arrow-select\" />);\n      \n      const select = screen.getByTestId('arrow-select');\n      fireEvent.keyDown(select, { key: 'ArrowDown' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n  });\n\n  describe('検索機能', () => {\n    it('searchable=trueで検索入力が表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"searchable-select\" />);\n      \n      await user.click(screen.getByTestId('searchable-select'));\n      \n      const searchInput = screen.getByTestId('searchable-select-search');\n      expect(searchInput).toBeInTheDocument();\n    });\n\n    it('検索によりオプションがフィルタリングされる', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"filter-select\" />);\n      \n      await user.click(screen.getByTestId('filter-select'));\n      \n      const searchInput = screen.getByTestId('filter-select-search');\n      await user.type(searchInput, 'オプション2');\n      \n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n      expect(screen.queryByText('オプション1')).not.toBeInTheDocument();\n    });\n\n    it('検索結果がない場合のメッセージが表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"no-results-select\" />);\n      \n      await user.click(screen.getByTestId('no-results-select'));\n      \n      const searchInput = screen.getByTestId('no-results-select-search');\n      await user.type(searchInput, '存在しないオプション');\n      \n      expect(screen.getByText('該当する項目がありません')).toBeInTheDocument();\n    });\n  });\n\n  describe('複数選択', () => {\n    it('multiple=trueで複数選択が可能', async () => {\n      const handleMultipleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          multiple \n          onMultipleChange={handleMultipleChange}\n          data-testid=\"multiple-select\" \n        />\n      );\n      \n      await user.click(screen.getByTestId('multiple-select'));\n      await user.click(screen.getByText('オプション1'));\n      \n      expect(handleMultipleChange).toHaveBeenCalledWith(['option1'], expect.any(Array));\n    });\n\n    it('複数選択時の表示が正しく動作する', async () => {\n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          multiple \n          multipleValue={['option1', 'option2']}\n          data-testid=\"multiple-display\" \n        />\n      );\n      \n      expect(screen.getByText('2件選択中')).toBeInTheDocument();\n    });\n  });\n\n  describe('アイコン表示', () => {\n    it('オプションのアイコンが正しく表示される', async () => {\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptionsWithIcons} data-testid=\"icon-select\" />);\n      \n      await user.click(screen.getByTestId('icon-select'));\n      \n      const icons = screen.getAllByTestId('test-icon');\n      expect(icons).toHaveLength(2);\n    });\n  });\n\n  describe('disabled状態', () => {\n    it('disabled=trueでセレクトが無効化される', () => {\n      render(<Select options={testOptions} disabled data-testid=\"disabled-select\" />);\n      \n      const select = screen.getByTestId('disabled-select');\n      expect(select).toHaveAttribute('tabIndex', '-1');\n    });\n\n    it('disabled状態でクリックイベントが発火しない', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} disabled data-testid=\"disabled-click\" />);\n      \n      const select = screen.getByTestId('disabled-click');\n      await user.click(select);\n      \n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n  });\n\n  describe('カスタムレンダリング', () => {\n    it('renderOptionが正しく動作する', async () => {\n      const renderOption = (option: SelectOption, isSelected: boolean) => (\n        <div data-testid={`custom-option-${option.value}`}>\n          カスタム: {option.label} {isSelected && '✓'}\n        </div>\n      );\n      \n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          renderOption={renderOption}\n          data-testid=\"custom-render\" \n        />\n      );\n      \n      await user.click(screen.getByTestId('custom-render'));\n      \n      expect(screen.getByTestId('custom-option-option1')).toBeInTheDocument();\n      expect(screen.getByText('カスタム: オプション1')).toBeInTheDocument();\n    });\n\n    it('renderSelectedValueが正しく動作する', () => {\n      const renderSelectedValue = (option: SelectOption | null) => (\n        option ? `選択中: ${option.label}` : '未選択'\n      );\n      \n      render(\n        <Select \n          options={testOptions}\n          value=\"option1\"\n          renderSelectedValue={renderSelectedValue}\n          data-testid=\"custom-value\" \n        />\n      );\n      \n      expect(screen.getByText('選択中: オプション1')).toBeInTheDocument();\n    });\n  });\n\n  describe('fullWidth', () => {\n    it('fullWidth=falseで幅が制限される', () => {\n      render(<Select options={testOptions} fullWidth={false} data-testid=\"limited-width\" />);\n      \n      const container = screen.getByTestId('limited-width').parentElement;\n      expect(container?.className).toContain('w-auto');\n    });\n  });\n\n  describe('アクセシビリティ', () => {\n    it('combobox roleが正しく設定される', () => {\n      render(<Select options={testOptions} data-testid=\"a11y-select\" />);\n      \n      const select = screen.getByTestId('a11y-select');\n      expect(select).toHaveAttribute('role', 'combobox');\n    });\n\n    it('aria-expanded属性が正しく設定される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"aria-expanded\" />);\n      \n      const select = screen.getByTestId('aria-expanded');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n      \n      await user.click(select);\n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('aria-required属性が正しく設定される', () => {\n      render(<Select options={testOptions} required data-testid=\"aria-required\" />);\n      \n      const select = screen.getByTestId('aria-required');\n      expect(select).toHaveAttribute('aria-required', 'true');\n    });\n  });\n\n  describe('型安全性', () => {\n    it('SelectPropsの型が正しく適用される', () => {\n      // 型チェックのみ（実行時エラーがないことを確認）\n      const selectProps: SelectProps = {\n        options: testOptions,\n        size: 'lg',\n        variant: 'success',\n        label: 'テストセレクト',\n        placeholder: 'カスタムプレースホルダー',\n        searchable: true,\n        multiple: false,\n        required: true,\n        'data-testid': 'type-safe-select'\n      };\n      \n      render(<Select {...selectProps} />);\n      \n      expect(screen.getByTestId('type-safe-select')).toBeInTheDocument();\n    });\n  });\n});"
     |      ^
  
✔ Launching dev servers for renderer process code
❯ Compiling main process code
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
vite v6.3.5 building for development...

watching for file changes...
vite v6.3.5 building for development...

watching for file changes...
13:42:05 [vite] (client) Pre-transform error: Transform failed with 1 error:
/Users/hirose/dev/mascot/src/renderer/components/common/FormField.test.tsx:33:40: ERROR: Syntax error "n"
  Plugin: vite:esbuild
  File: /Users/hirose/dev/mascot/src/renderer/components/common/FormField.test.tsx:33:40
  
  Syntax error "n"
  31 |  ];
  32 |  
  33 |  describe('FormField Component', () => {\n  describe('基本的なレンダリング', () => {\n    it('デフォルトのpropsで正常にレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"input\" \n          label=\"テストフィールド\"\n          data-testid=\"default-field\" \n        />\n      );\n      \n      expect(screen.getByTestId('default-field')).toBeInTheDocument();\n      expect(screen.getByText('テストフィールド')).toBeInTheDocument();\n      expect(screen.getByTestId('default-field-field')).toBeInTheDocument();\n    });\n\n    it('カスタムchildrenが正しく表示される', () => {\n      render(\n        <FormField \n          label=\"カスタムフィールド\"\n          data-testid=\"custom-field\"\n        >\n          <div data-testid=\"custom-content\">カスタムコンテンツ</div>\n        </FormField>\n      );\n      \n      expect(screen.getByTestId('custom-content')).toBeInTheDocument();\n      expect(screen.getByText('カスタムコンテンツ')).toBeInTheDocument();\n    });\n  });\n\n  describe('フィールドタイプ', () => {\n    it('type=\"input\"で入力フィールドがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"入力フィールド\"\n          inputProps={{ placeholder: 'テキストを入力' }}\n          data-testid=\"input-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('input-field-field');\n      expect(input).toBeInTheDocument();\n      expect(input).toHaveAttribute('type', 'text');\n      expect(input).toHaveAttribute('placeholder', 'テキストを入力');\n    });\n\n    it('type=\"select\"で選択フィールドがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"select\"\n          label=\"選択フィールド\"\n          selectProps={{ options: testSelectOptions, placeholder: '選択してください' }}\n          data-testid=\"select-field\"\n        />\n      );\n      \n      const select = screen.getByTestId('select-field-field');\n      expect(select).toBeInTheDocument();\n      expect(select).toHaveAttribute('role', 'combobox');\n      expect(screen.getByText('選択してください')).toBeInTheDocument();\n    });\n\n    it('type=\"textarea\"でテキストエリアがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"textarea\"\n          label=\"テキストエリア\"\n          textareaProps={{ placeholder: '詳細を入力', rows: 4 }}\n          data-testid=\"textarea-field\"\n        />\n      );\n      \n      const textarea = screen.getByTestId('textarea-field-field');\n      expect(textarea).toBeInTheDocument();\n      expect(textarea.tagName).toBe('TEXTAREA');\n      expect(textarea).toHaveAttribute('placeholder', '詳細を入力');\n      expect(textarea).toHaveAttribute('rows', '4');\n    });\n\n    it('type=\"checkbox\"でチェックボックスがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"チェックボックス\"\n          checkboxProps={{ value: 'check1' }}\n          data-testid=\"checkbox-field\"\n        />\n      );\n      \n      const checkbox = screen.getByTestId('checkbox-field-field');\n      expect(checkbox).toBeInTheDocument();\n      expect(checkbox).toHaveAttribute('type', 'checkbox');\n      expect(checkbox).toHaveAttribute('value', 'check1');\n      \n      // チェックボックスの場合、ラベルは横に表示される\n      const label = screen.getByText('チェックボックス');\n      expect(label).toBeInTheDocument();\n    });\n\n    it('type=\"radio\"でラジオボタンがレンダリングされる', () => {\n      render(\n        <FormField \n          type=\"radio\"\n          label=\"ラジオボタン\"\n          options={testRadioOptions}\n          radioProps={{ name: 'test-radio' }}\n          data-testid=\"radio-field\"\n        />\n      );\n      \n      // 各ラジオオプションが表示される\n      testRadioOptions.forEach(option => {\n        expect(screen.getByText(option.label)).toBeInTheDocument();\n      });\n      \n      // 無効なオプションが正しく無効化される\n      const radioInputs = screen.getAllByRole('radio');\n      expect(radioInputs).toHaveLength(3);\n      expect(radioInputs[2]).toBeDisabled(); // 3番目のオプションは無効\n    });\n\n    it('type=\"button\"でボタンがレンダリングされる', () => {\n      const handleClick = vi.fn();\n      \n      render(\n        <FormField \n          type=\"button\"\n          label=\"送信\"\n          buttonProps={{ variant: 'primary', onClick: handleClick }}\n          data-testid=\"button-field\"\n        />\n      );\n      \n      const button = screen.getByRole('button', { name: '送信' });\n      expect(button).toBeInTheDocument();\n      expect(button).toHaveTextContent('送信');\n    });\n  });\n\n  describe('レイアウト', () => {\n    const layouts: FormFieldLayout[] = ['vertical', 'horizontal', 'inline'];\n\n    layouts.forEach(layout => {\n      it(`layout=\"${layout}\" が正しく適用される`, () => {\n        render(\n          <FormField \n            type=\"input\"\n            label=\"レイアウトテスト\"\n            layout={layout}\n            data-testid={`${layout}-field`}\n          />\n        );\n        \n        const field = screen.getByTestId(`${layout}-field`);\n        expect(field).toBeInTheDocument();\n        \n        if (layout === 'vertical') {\n          expect(field.className).toContain('flex-col');\n        } else if (layout === 'horizontal') {\n          expect(field.className).toContain('flex');\n          expect(field.className).toContain('items-start');\n        } else if (layout === 'inline') {\n          expect(field.className).toContain('flex');\n          expect(field.className).toContain('items-center');\n        }\n      });\n    });\n\n    it('horizontalレイアウトでlabelWidthが適用される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"ラベル幅テスト\"\n          layout=\"horizontal\"\n          labelWidth=\"200px\"\n          data-testid=\"label-width-field\"\n        />\n      );\n      \n      const label = screen.getByText('ラベル幅テスト');\n      expect(label).toHaveStyle({ width: '200px' });\n    });\n  });\n\n  describe('サイズ', () => {\n    const sizes: FormFieldSize[] = ['sm', 'md', 'lg'];\n\n    sizes.forEach(size => {\n      it(`size=\"${size}\" が正しく適用される`, () => {\n        render(\n          <FormField \n            type=\"input\"\n            label=\"サイズテスト\"\n            size={size}\n            data-testid={`${size}-size-field`}\n          />\n        );\n        \n        const input = screen.getByTestId(`${size}-size-field-field`);\n        expect(input).toBeInTheDocument();\n        \n        if (size === 'sm') {\n          expect(input.className).toContain('text-xs');\n        } else if (size === 'lg') {\n          expect(input.className).toContain('text-base');\n        }\n      });\n    });\n  });\n\n  describe('必須フィールド', () => {\n    it('required=trueで必須マークが表示される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"必須フィールド\"\n          required\n          data-testid=\"required-field\"\n        />\n      );\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n      expect(requiredMark).toHaveTextContent('*');\n    });\n\n    it('チェックボックスで必須マークが正しく表示される', () => {\n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"必須チェック\"\n          required\n          data-testid=\"required-checkbox\"\n        />\n      );\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n    });\n  });\n\n  describe('エラーメッセージ', () => {\n    it('エラーメッセージが正しく表示される', () => {\n      const errorMessage = 'このフィールドは必須です';\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーフィールド\"\n          error={errorMessage}\n          data-testid=\"error-field\"\n        />\n      );\n      \n      const errorElement = screen.getByTestId('error-field-error');\n      expect(errorElement).toBeInTheDocument();\n      expect(errorElement).toHaveTextContent(errorMessage);\n      expect(errorElement).toHaveAttribute('role', 'alert');\n    });\n\n    it('エラーがある場合はヘルプテキストは表示されない', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーヘルプテスト\"\n          error=\"エラーメッセージ\"\n          helpText=\"ヘルプテキスト\"\n          data-testid=\"error-help-field\"\n        />\n      );\n      \n      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();\n      expect(screen.queryByText('ヘルプテキスト')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('ヘルプテキスト', () => {\n    it('ヘルプテキストが正しく表示される', () => {\n      const helpText = '半角英数字で入力してください';\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"ヘルプフィールド\"\n          helpText={helpText}\n          data-testid=\"help-field\"\n        />\n      );\n      \n      const helpElement = screen.getByTestId('help-field-help');\n      expect(helpElement).toBeInTheDocument();\n      expect(helpElement).toHaveTextContent(helpText);\n    });\n  });\n\n  describe('disabled状態', () => {\n    it('disabled=trueでフィールドが無効化される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"無効フィールド\"\n          disabled\n          data-testid=\"disabled-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('disabled-field-field');\n      expect(input).toBeDisabled();\n    });\n\n    it('ラジオボタンで個別とグローバルの無効化が正しく動作する', () => {\n      render(\n        <FormField \n          type=\"radio\"\n          label=\"無効ラジオ\"\n          options={testRadioOptions}\n          disabled\n          data-testid=\"disabled-radio\"\n        />\n      );\n      \n      const radioInputs = screen.getAllByRole('radio');\n      radioInputs.forEach(radio => {\n        expect(radio).toBeDisabled();\n      });\n    });\n  });\n\n  describe('fullWidth', () => {\n    it('fullWidth=falseで幅が制限される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"幅制限フィールド\"\n          fullWidth={false}\n          data-testid=\"limited-width-field\"\n        />\n      );\n      \n      const field = screen.getByTestId('limited-width-field');\n      expect(field.className).toContain('w-auto');\n    });\n  });\n\n  describe('イベントハンドリング', () => {\n    it('入力フィールドでイベントが正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"input\"\n          label=\"イベントテスト\"\n          inputProps={{ onChange: handleChange }}\n          data-testid=\"event-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('event-field-field');\n      await user.type(input, 'テスト');\n      \n      expect(handleChange).toHaveBeenCalled();\n    });\n\n    it('チェックボックスでイベントが正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"checkbox\"\n          label=\"チェックイベント\"\n          checkboxProps={{ onChange: handleChange }}\n          data-testid=\"checkbox-event\"\n        />\n      );\n      \n      const checkbox = screen.getByTestId('checkbox-event-field');\n      await user.click(checkbox);\n      \n      expect(handleChange).toHaveBeenCalled();\n    });\n\n    it('ボタンでイベントが正しく動作する', async () => {\n      const handleClick = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <FormField \n          type=\"button\"\n          label=\"クリック\"\n          buttonProps={{ onClick: handleClick }}\n          data-testid=\"button-event\"\n        />\n      );\n      \n      const button = screen.getByRole('button', { name: 'クリック' });\n      await user.click(button);\n      \n      expect(handleClick).toHaveBeenCalled();\n    });\n  });\n\n  describe('アクセシビリティ', () => {\n    it('ラベルとフィールドが正しく関連付けられる', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"アクセシブルフィールド\"\n          data-testid=\"accessible-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('accessible-field-field');\n      const label = screen.getByText('アクセシブルフィールド');\n      \n      expect(label).toHaveAttribute('for', input.id);\n    });\n\n    it('エラー状態でaria属性が正しく設定される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"エラーアクセシビリティ\"\n          error=\"エラーです\"\n          data-testid=\"error-a11y-field\"\n        />\n      );\n      \n      const input = screen.getByTestId('error-a11y-field-field');\n      expect(input).toHaveAttribute('aria-invalid', 'true');\n    });\n  });\n\n  describe('カスタマイズ', () => {\n    it('カスタムクラスが正しく適用される', () => {\n      render(\n        <FormField \n          type=\"input\"\n          label=\"カスタムクラス\"\n          className=\"custom-field\"\n          labelClassName=\"custom-label\"\n          fieldClassName=\"custom-field-container\"\n          errorClassName=\"custom-error\"\n          helpClassName=\"custom-help\"\n          error=\"エラー\"\n          helpText=\"ヘルプ\"\n          data-testid=\"custom-classes\"\n        />\n      );\n      \n      const field = screen.getByTestId('custom-classes');\n      expect(field.className).toContain('custom-field');\n      \n      const label = screen.getByText('カスタムクラス');\n      expect(label.className).toContain('custom-label');\n    });\n  });\n\n  describe('型安全性', () => {\n    it('FormFieldPropsの型が正しく適用される', () => {\n      // 型チェックのみ（実行時エラーがないことを確認）\n      const formFieldProps: FormFieldProps = {\n        type: 'input',\n        label: 'タイプセーフフィールド',\n        layout: 'horizontal',\n        size: 'lg',\n        required: true,\n        fullWidth: false,\n        inputProps: {\n          type: 'email',\n          placeholder: 'example@domain.com'\n        },\n        'data-testid': 'type-safe-field'\n      };\n      \n      render(<FormField {...formFieldProps} />);\n      \n      expect(screen.getByTestId('type-safe-field')).toBeInTheDocument();\n    });\n  });\n});"
     |                                          ^
  
13:42:05 [vite] (client) Pre-transform error: Transform failed with 1 error:
/Users/hirose/dev/mascot/src/renderer/components/common/Select.test.tsx:6:4: ERROR: Syntax error "n"
  Plugin: vite:esbuild
  File: /Users/hirose/dev/mascot/src/renderer/components/common/Select.test.tsx:6:4
  
  Syntax error "n"
  4  |   * Phase 3.5.2.1 Task 3: Selectコンポーネントテスト
  5  |   * TypeScript厳密型定義、アクセシビリティ、ドロップダウン機能のテスト
  6  |   */\n\nimport React from 'react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n// テスト対象\nimport Select, { type SelectProps, type SelectOption, type SelectSize, type SelectVariant } from './Select';\n\n// テスト用のオプションデータ\nconst testOptions: SelectOption[] = [\n  { value: 'option1', label: 'オプション1' },\n  { value: 'option2', label: 'オプション2', description: '説明2' },\n  { value: 'option3', label: 'オプション3', disabled: true },\n  { value: 'option4', label: 'オプション4', description: '説明4' },\n];\n\n// テスト用のアイコン付きオプション\nconst TestIcon: React.FC = () => (\n  <svg data-testid=\"test-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n    <circle cx=\"8\" cy=\"8\" r=\"4\" />\n  </svg>\n);\n\nconst testOptionsWithIcons: SelectOption[] = [\n  { value: 'icon1', label: 'アイコン1', icon: <TestIcon /> },\n  { value: 'icon2', label: 'アイコン2', icon: <TestIcon /> },\n];\n\ndescribe('Select Component', () => {\n  describe('基本的なレンダリング', () => {\n    it('デフォルトのpropsで正常にレンダリングされる', () => {\n      render(<Select options={testOptions} data-testid=\"default-select\" />);\n      \n      const select = screen.getByTestId('default-select');\n      expect(select).toBeInTheDocument();\n      expect(select).toHaveAttribute('role', 'combobox');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n\n    it('プレースホルダーが正しく表示される', () => {\n      const placeholder = 'カスタムプレースホルダー';\n      render(<Select options={testOptions} placeholder={placeholder} data-testid=\"placeholder-select\" />);\n      \n      expect(screen.getByText(placeholder)).toBeInTheDocument();\n    });\n\n    it('デフォルト値が正しく設定される', () => {\n      render(\n        <Select \n          options={testOptions} \n          defaultValue=\"option2\" \n          data-testid=\"default-value-select\" \n        />\n      );\n      \n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n    });\n  });\n\n  describe('サイズ（size）', () => {\n    const sizes: SelectSize[] = ['sm', 'md', 'lg'];\n\n    sizes.forEach(size => {\n      it(`size=\"${size}\" が正しく適用される`, () => {\n        render(<Select options={testOptions} size={size} data-testid={`${size}-select`} />);\n        \n        const select = screen.getByTestId(`${size}-select`);\n        expect(select).toBeInTheDocument();\n        \n        if (size === 'sm') {\n          expect(select.className).toContain('text-xs');\n        } else if (size === 'lg') {\n          expect(select.className).toContain('text-base');\n        }\n      });\n    });\n  });\n\n  describe('バリアント（variant）', () => {\n    const variants: SelectVariant[] = ['default', 'error', 'success'];\n\n    variants.forEach(variant => {\n      it(`variant=\"${variant}\" が正しく適用される`, () => {\n        render(<Select options={testOptions} variant={variant} data-testid={`${variant}-select`} />);\n        \n        const select = screen.getByTestId(`${variant}-select`);\n        expect(select).toBeInTheDocument();\n        \n        if (variant === 'error') {\n          expect(select.className).toContain('border-red-500');\n          expect(select).toHaveAttribute('aria-invalid', 'true');\n        } else if (variant === 'success') {\n          expect(select.className).toContain('border-green-500');\n        }\n      });\n    });\n  });\n\n  describe('ラベル', () => {\n    it('ラベルが正しく表示される', () => {\n      const label = 'セレクトラベル';\n      render(<Select options={testOptions} label={label} data-testid=\"labeled-select\" />);\n      \n      const labelElement = screen.getByText(label);\n      const select = screen.getByTestId('labeled-select');\n      \n      expect(labelElement).toBeInTheDocument();\n      expect(labelElement).toHaveAttribute('for', select.id);\n    });\n\n    it('required=trueで必須マークが表示される', () => {\n      render(<Select options={testOptions} label=\"必須セレクト\" required data-testid=\"required-select\" />);\n      \n      const requiredMark = screen.getByLabelText('必須');\n      expect(requiredMark).toBeInTheDocument();\n      expect(requiredMark).toHaveTextContent('*');\n    });\n  });\n\n  describe('エラーメッセージ', () => {\n    it('エラーメッセージが正しく表示される', () => {\n      const errorMessage = '選択が必要です';\n      render(<Select options={testOptions} error={errorMessage} data-testid=\"error-select\" />);\n      \n      const select = screen.getByTestId('error-select');\n      const errorElement = screen.getByTestId('error-select-error');\n      \n      expect(errorElement).toBeInTheDocument();\n      expect(errorElement).toHaveTextContent(errorMessage);\n      expect(errorElement).toHaveAttribute('role', 'alert');\n      expect(select).toHaveAttribute('aria-invalid', 'true');\n    });\n\n    it('エラーがある場合はvariantがerrorに変更される', () => {\n      render(<Select options={testOptions} variant=\"success\" error=\"エラーです\" data-testid=\"error-override\" />);\n      \n      const select = screen.getByTestId('error-override');\n      expect(select.className).toContain('border-red-500');\n    });\n  });\n\n  describe('ヘルプテキスト', () => {\n    it('ヘルプテキストが正しく表示される', () => {\n      const helpText = '選択してください';\n      render(<Select options={testOptions} helpText={helpText} data-testid=\"help-select\" />);\n      \n      const helpElement = screen.getByTestId('help-select-help');\n      expect(helpElement).toBeInTheDocument();\n      expect(helpElement).toHaveTextContent(helpText);\n    });\n\n    it('エラーがある場合はヘルプテキストは表示されない', () => {\n      render(\n        <Select \n          options={testOptions}\n          helpText=\"ヘルプテキスト\" \n          error=\"エラーメッセージ\" \n          data-testid=\"error-help-select\"\n        />\n      );\n      \n      expect(screen.queryByText('ヘルプテキスト')).not.toBeInTheDocument();\n      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();\n    });\n  });\n\n  describe('ドロップダウン操作', () => {\n    it('クリックでドロップダウンが開く', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"dropdown-select\" />);\n      \n      const select = screen.getByTestId('dropdown-select');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n      \n      await user.click(select);\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n      expect(screen.getByRole('listbox')).toBeInTheDocument();\n    });\n\n    it('オプションが正しく表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"options-select\" />);\n      \n      await user.click(screen.getByTestId('options-select'));\n      \n      testOptions.forEach(option => {\n        expect(screen.getByText(option.label)).toBeInTheDocument();\n      });\n    });\n\n    it('オプション選択が正しく動作する', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptions} onChange={handleChange} data-testid=\"select-option\" />);\n      \n      await user.click(screen.getByTestId('select-option'));\n      await user.click(screen.getByText('オプション2'));\n      \n      expect(handleChange).toHaveBeenCalledWith('option2', testOptions[1]);\n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n    });\n\n    it('無効なオプションは選択できない', async () => {\n      const handleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptions} onChange={handleChange} data-testid=\"disabled-option\" />);\n      \n      await user.click(screen.getByTestId('disabled-option'));\n      await user.click(screen.getByText('オプション3'));\n      \n      expect(handleChange).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('キーボードナビゲーション', () => {\n    it('Enterキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"keyboard-select\" />);\n      \n      const select = screen.getByTestId('keyboard-select');\n      fireEvent.keyDown(select, { key: 'Enter' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('Spaceキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"space-select\" />);\n      \n      const select = screen.getByTestId('space-select');\n      fireEvent.keyDown(select, { key: ' ' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('Escapeキーでドロップダウンが閉じる', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"escape-select\" />);\n      \n      const select = screen.getByTestId('escape-select');\n      await user.click(select);\n      expect(select).toHaveAttribute('aria-expanded', 'true');\n      \n      fireEvent.keyDown(select, { key: 'Escape' });\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n\n    it('ArrowDownキーでドロップダウンが開く', () => {\n      render(<Select options={testOptions} data-testid=\"arrow-select\" />);\n      \n      const select = screen.getByTestId('arrow-select');\n      fireEvent.keyDown(select, { key: 'ArrowDown' });\n      \n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n  });\n\n  describe('検索機能', () => {\n    it('searchable=trueで検索入力が表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"searchable-select\" />);\n      \n      await user.click(screen.getByTestId('searchable-select'));\n      \n      const searchInput = screen.getByTestId('searchable-select-search');\n      expect(searchInput).toBeInTheDocument();\n    });\n\n    it('検索によりオプションがフィルタリングされる', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"filter-select\" />);\n      \n      await user.click(screen.getByTestId('filter-select'));\n      \n      const searchInput = screen.getByTestId('filter-select-search');\n      await user.type(searchInput, 'オプション2');\n      \n      expect(screen.getByText('オプション2')).toBeInTheDocument();\n      expect(screen.queryByText('オプション1')).not.toBeInTheDocument();\n    });\n\n    it('検索結果がない場合のメッセージが表示される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} searchable data-testid=\"no-results-select\" />);\n      \n      await user.click(screen.getByTestId('no-results-select'));\n      \n      const searchInput = screen.getByTestId('no-results-select-search');\n      await user.type(searchInput, '存在しないオプション');\n      \n      expect(screen.getByText('該当する項目がありません')).toBeInTheDocument();\n    });\n  });\n\n  describe('複数選択', () => {\n    it('multiple=trueで複数選択が可能', async () => {\n      const handleMultipleChange = vi.fn();\n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          multiple \n          onMultipleChange={handleMultipleChange}\n          data-testid=\"multiple-select\" \n        />\n      );\n      \n      await user.click(screen.getByTestId('multiple-select'));\n      await user.click(screen.getByText('オプション1'));\n      \n      expect(handleMultipleChange).toHaveBeenCalledWith(['option1'], expect.any(Array));\n    });\n\n    it('複数選択時の表示が正しく動作する', async () => {\n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          multiple \n          multipleValue={['option1', 'option2']}\n          data-testid=\"multiple-display\" \n        />\n      );\n      \n      expect(screen.getByText('2件選択中')).toBeInTheDocument();\n    });\n  });\n\n  describe('アイコン表示', () => {\n    it('オプションのアイコンが正しく表示される', async () => {\n      const user = userEvent.setup();\n      \n      render(<Select options={testOptionsWithIcons} data-testid=\"icon-select\" />);\n      \n      await user.click(screen.getByTestId('icon-select'));\n      \n      const icons = screen.getAllByTestId('test-icon');\n      expect(icons).toHaveLength(2);\n    });\n  });\n\n  describe('disabled状態', () => {\n    it('disabled=trueでセレクトが無効化される', () => {\n      render(<Select options={testOptions} disabled data-testid=\"disabled-select\" />);\n      \n      const select = screen.getByTestId('disabled-select');\n      expect(select).toHaveAttribute('tabIndex', '-1');\n    });\n\n    it('disabled状態でクリックイベントが発火しない', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} disabled data-testid=\"disabled-click\" />);\n      \n      const select = screen.getByTestId('disabled-click');\n      await user.click(select);\n      \n      expect(select).toHaveAttribute('aria-expanded', 'false');\n    });\n  });\n\n  describe('カスタムレンダリング', () => {\n    it('renderOptionが正しく動作する', async () => {\n      const renderOption = (option: SelectOption, isSelected: boolean) => (\n        <div data-testid={`custom-option-${option.value}`}>\n          カスタム: {option.label} {isSelected && '✓'}\n        </div>\n      );\n      \n      const user = userEvent.setup();\n      \n      render(\n        <Select \n          options={testOptions} \n          renderOption={renderOption}\n          data-testid=\"custom-render\" \n        />\n      );\n      \n      await user.click(screen.getByTestId('custom-render'));\n      \n      expect(screen.getByTestId('custom-option-option1')).toBeInTheDocument();\n      expect(screen.getByText('カスタム: オプション1')).toBeInTheDocument();\n    });\n\n    it('renderSelectedValueが正しく動作する', () => {\n      const renderSelectedValue = (option: SelectOption | null) => (\n        option ? `選択中: ${option.label}` : '未選択'\n      );\n      \n      render(\n        <Select \n          options={testOptions}\n          value=\"option1\"\n          renderSelectedValue={renderSelectedValue}\n          data-testid=\"custom-value\" \n        />\n      );\n      \n      expect(screen.getByText('選択中: オプション1')).toBeInTheDocument();\n    });\n  });\n\n  describe('fullWidth', () => {\n    it('fullWidth=falseで幅が制限される', () => {\n      render(<Select options={testOptions} fullWidth={false} data-testid=\"limited-width\" />);\n      \n      const container = screen.getByTestId('limited-width').parentElement;\n      expect(container?.className).toContain('w-auto');\n    });\n  });\n\n  describe('アクセシビリティ', () => {\n    it('combobox roleが正しく設定される', () => {\n      render(<Select options={testOptions} data-testid=\"a11y-select\" />);\n      \n      const select = screen.getByTestId('a11y-select');\n      expect(select).toHaveAttribute('role', 'combobox');\n    });\n\n    it('aria-expanded属性が正しく設定される', async () => {\n      const user = userEvent.setup();\n      render(<Select options={testOptions} data-testid=\"aria-expanded\" />);\n      \n      const select = screen.getByTestId('aria-expanded');\n      expect(select).toHaveAttribute('aria-expanded', 'false');\n      \n      await user.click(select);\n      expect(select).toHaveAttribute('aria-expanded', 'true');\n    });\n\n    it('aria-required属性が正しく設定される', () => {\n      render(<Select options={testOptions} required data-testid=\"aria-required\" />);\n      \n      const select = screen.getByTestId('aria-required');\n      expect(select).toHaveAttribute('aria-required', 'true');\n    });\n  });\n\n  describe('型安全性', () => {\n    it('SelectPropsの型が正しく適用される', () => {\n      // 型チェックのみ（実行時エラーがないことを確認）\n      const selectProps: SelectProps = {\n        options: testOptions,\n        size: 'lg',\n        variant: 'success',\n        label: 'テストセレクト',\n        placeholder: 'カスタムプレースホルダー',\n        searchable: true,\n        multiple: false,\n        required: true,\n        'data-testid': 'type-safe-select'\n      };\n      \n      render(<Select {...selectProps} />);\n      \n      expect(screen.getByTestId('type-safe-select')).toBeInTheDocument();\n    });\n  });\n});"
     |      ^
  
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";

build started...

build started...
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
13:42:05 [vite] (client) Pre-transform error: Failed to resolve import "./FormField" from "src/renderer/components/common/index.ts". Does the file exist?
  Plugin: vite:import-analysis
  File: /Users/hirose/dev/mascot/src/renderer/components/common/index.ts:35:37
  3  |  export { default as Input } from "./Input";
  4  |  export { default as Select } from "./Select";
  5  |  export { default as FormField } from "./FormField";
     |                                        ^
  6  |  export { default as Card } from "./Card";
  7  |  export { default as LazyComponent, LazySettingsWindow, LazyChatApp, useComponentLoading } from "./LazyComponent";
transforming...
transforming...
✓ 1 modules transformed.
rendering chunks...
computing gzip size...
.vite/build/preload.js  7.04 kB │ gzip: 1.47 kB
built in 56ms.
✓ 432 modules transformed.
rendering chunks...
computing gzip size...
.vite/build/main.js  840.34 kB │ gzip: 167.11 kB
built in 579ms.
✔ Compiling main process code
✔ [plugin-vite] Preparing vite bundles
✔ Running preStart hook
[?25h
[SettingsStore] 設定ファイル保存場所: /Users/hirose/Library/Application Support/llmdesktopmascot/app-settings.json
[SettingsStore] 現在保存されているデータ: [Object: null prototype] {
  windowSize: { width: 400, height: 600, preset: 'medium' },
  vrmModelPath: '/avatar.vrm',
  cameraSettings: {
    position: { x: 0, y: 1.2, z: 5 },
    target: { x: 0, y: 1, z: 0 },
    zoom: 1
  },
  chatWindowVisible: false,
  userName: 'User',
  mascotName: 'Mascot',
  systemPromptCore: 'あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。',
  theme: 'default',
  defaultExpression: 'neutral',
  expressionSettings: {
    happy: { enabled: true, defaultWeight: 1 },
    sad: { enabled: true, defaultWeight: 1 },
    angry: { enabled: true, defaultWeight: 1 },
    surprised: { enabled: true, defaultWeight: 1 },
    relaxed: { enabled: true, defaultWeight: 1 },
    neutral: { enabled: true, defaultWeight: 1 },
    fun: { enabled: true, defaultWeight: 1 },
    joy: { enabled: true, defaultWeight: 1 },
    sorrow: { enabled: true, defaultWeight: 1 },
    aa: { enabled: true, defaultWeight: 1 },
    ih: { enabled: true, defaultWeight: 1 },
    ou: { enabled: true, defaultWeight: 1 },
    ee: { enabled: true, defaultWeight: 1 },
    oh: { enabled: true, defaultWeight: 1 },
    blink: { enabled: true, defaultWeight: 1 },
    blinkL: { enabled: true, defaultWeight: 1 },
    blinkR: { enabled: true, defaultWeight: 1 }
  },
  mainWindowBounds: { x: 967, y: 211, width: 400, height: 600 }
}
[SettingsStore] 既存の表情設定を使用します: [
  'happy',   'sad',
  'angry',   'surprised',
  'relaxed', 'neutral',
  'fun',     'joy',
  'sorrow',  'aa',
  'ih',      'ou',
  'ee',      'oh',
  'blink',   'blinkL',
  'blinkR'
]
[SettingsStore] 設定ファイル保存場所: /Users/hirose/Library/Application Support/llmdesktopmascot/app-settings.json
[SettingsStore] 現在保存されているデータ: [Object: null prototype] {
  windowSize: { width: 400, height: 600, preset: 'medium' },
  vrmModelPath: '/avatar.vrm',
  cameraSettings: {
    position: { x: 0, y: 1.2, z: 5 },
    target: { x: 0, y: 1, z: 0 },
    zoom: 1
  },
  chatWindowVisible: false,
  userName: 'User',
  mascotName: 'Mascot',
  systemPromptCore: 'あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。',
  theme: 'default',
  defaultExpression: 'neutral',
  expressionSettings: {
    happy: { enabled: true, defaultWeight: 1 },
    sad: { enabled: true, defaultWeight: 1 },
    angry: { enabled: true, defaultWeight: 1 },
    surprised: { enabled: true, defaultWeight: 1 },
    relaxed: { enabled: true, defaultWeight: 1 },
    neutral: { enabled: true, defaultWeight: 1 },
    fun: { enabled: true, defaultWeight: 1 },
    joy: { enabled: true, defaultWeight: 1 },
    sorrow: { enabled: true, defaultWeight: 1 },
    aa: { enabled: true, defaultWeight: 1 },
    ih: { enabled: true, defaultWeight: 1 },
    ou: { enabled: true, defaultWeight: 1 },
    ee: { enabled: true, defaultWeight: 1 },
    oh: { enabled: true, defaultWeight: 1 },
    blink: { enabled: true, defaultWeight: 1 },
    blinkL: { enabled: true, defaultWeight: 1 },
    blinkR: { enabled: true, defaultWeight: 1 }
  },
  mainWindowBounds: { x: 967, y: 211, width: 400, height: 600 }
}
[SettingsStore] 既存の表情設定を使用します: [
  'happy',   'sad',
  'angry',   'surprised',
  'relaxed', 'neutral',
  'fun',     'joy',
  'sorrow',  'aa',
  'ih',      'ou',
  'ee',      'oh',
  'blink',   'blinkL',
  'blinkR'
]
[SettingsStore] 設定ファイル保存場所: /Users/hirose/Library/Application Support/llmdesktopmascot/app-settings.json
[SettingsStore] 現在保存されているデータ: [Object: null prototype] {
  windowSize: { width: 400, height: 600, preset: 'medium' },
  vrmModelPath: '/avatar.vrm',
  cameraSettings: {
    position: { x: 0, y: 1.2, z: 5 },
    target: { x: 0, y: 1, z: 0 },
    zoom: 1
  },
  chatWindowVisible: false,
  userName: 'User',
  mascotName: 'Mascot',
  systemPromptCore: 'あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。',
  theme: 'default',
  defaultExpression: 'neutral',
  expressionSettings: {
    happy: { enabled: true, defaultWeight: 1 },
    sad: { enabled: true, defaultWeight: 1 },
    angry: { enabled: true, defaultWeight: 1 },
    surprised: { enabled: true, defaultWeight: 1 },
    relaxed: { enabled: true, defaultWeight: 1 },
    neutral: { enabled: true, defaultWeight: 1 },
    fun: { enabled: true, defaultWeight: 1 },
    joy: { enabled: true, defaultWeight: 1 },
    sorrow: { enabled: true, defaultWeight: 1 },
    aa: { enabled: true, defaultWeight: 1 },
    ih: { enabled: true, defaultWeight: 1 },
    ou: { enabled: true, defaultWeight: 1 },
    ee: { enabled: true, defaultWeight: 1 },
    oh: { enabled: true, defaultWeight: 1 },
    blink: { enabled: true, defaultWeight: 1 },
    blinkL: { enabled: true, defaultWeight: 1 },
    blinkR: { enabled: true, defaultWeight: 1 }
  },
  mainWindowBounds: { x: 967, y: 211, width: 400, height: 600 }
}
[SettingsStore] 既存の表情設定を使用します: [
  'happy',   'sad',
  'angry',   'surprised',
  'relaxed', 'neutral',
  'fun',     'joy',
  'sorrow',  'aa',
  'ih',      'ou',
  'ee',      'oh',
  'blink',   'blinkL',
  'blinkR'
]
[SettingsStore] 設定ファイル保存場所: /Users/hirose/Library/Application Support/llmdesktopmascot/app-settings.json
[SettingsStore] 現在保存されているデータ: [Object: null prototype] {
  windowSize: { width: 400, height: 600, preset: 'medium' },
  vrmModelPath: '/avatar.vrm',
  cameraSettings: {
    position: { x: 0, y: 1.2, z: 5 },
    target: { x: 0, y: 1, z: 0 },
    zoom: 1
  },
  chatWindowVisible: false,
  userName: 'User',
  mascotName: 'Mascot',
  systemPromptCore: 'あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。',
  theme: 'default',
  defaultExpression: 'neutral',
  expressionSettings: {
    happy: { enabled: true, defaultWeight: 1 },
    sad: { enabled: true, defaultWeight: 1 },
    angry: { enabled: true, defaultWeight: 1 },
    surprised: { enabled: true, defaultWeight: 1 },
    relaxed: { enabled: true, defaultWeight: 1 },
    neutral: { enabled: true, defaultWeight: 1 },
    fun: { enabled: true, defaultWeight: 1 },
    joy: { enabled: true, defaultWeight: 1 },
    sorrow: { enabled: true, defaultWeight: 1 },
    aa: { enabled: true, defaultWeight: 1 },
    ih: { enabled: true, defaultWeight: 1 },
    ou: { enabled: true, defaultWeight: 1 },
    ee: { enabled: true, defaultWeight: 1 },
    oh: { enabled: true, defaultWeight: 1 },
    blink: { enabled: true, defaultWeight: 1 },
    blinkL: { enabled: true, defaultWeight: 1 },
    blinkR: { enabled: true, defaultWeight: 1 }
  },
  mainWindowBounds: { x: 967, y: 211, width: 400, height: 600 }
}
[SettingsStore] 既存の表情設定を使用します: [
  'happy',   'sad',
  'angry',   'surprised',
  'relaxed', 'neutral',
  'fun',     'joy',
  'sorrow',  'aa',
  'ih',      'ou',
  'ee',      'oh',
  'blink',   'blinkL',
  'blinkR'
]
[ToolsService] アプリケーションパス: /Users/hirose/dev/mascot
[ToolsService] 作業ディレクトリ: /Users/hirose/dev/mascot
[ToolsService] リソースパス: /Users/hirose/dev/mascot/node_modules/electron/dist/Electron.app/Contents/Resources
[ToolsService] tools.json候補パスをチェック: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] tools.jsonが見つかりました: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] ツールファイルを読み込み中: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] 3個のツールが正常に読み込まれました:
  - set_expression: VRMマスコットの表情を設定します。表情を変えることで、マスコットの感情表現を豊かにできます。
  - get_weather_forecast: 指定された都市の現在の天気予報と気温を取得します（デモ用関数）。
  - set_reminder: 指定された時間にリマインダーを設定します（デモ用関数）。
Function Calling用ツールを読み込み: 3 個
構築されたシステムプロンプト: Your role is a desktop mascot named Mascot. You operate on the desktop of a user whose name is User. In all following interactions, you must use the names Mascot (for yourself) and User (for the user) correctly and appropriately. あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。
Gemini Service が正常に初期化されました（Function Calling対応）
Gemini Service とFunction Calling が初期化されました
[Main] 新しいIPC構造でハンドラーを設定中...
[SettingsHandler] 設定関連IPCハンドラーを登録中...
[SettingsHandler] すべての設定関連IPCハンドラーが登録されました
[ChatHandler] チャット関連IPCハンドラーを登録中...
[ChatHandler] すべてのチャット関連IPCハンドラーが登録されました
[VRMHandler] VRM/ウィンドウ制御関連IPCハンドラーを登録中...
[VRMHandler] すべてのVRM/ウィンドウ制御関連IPCハンドラーが登録されました
[Main] 新しいIPC構造でのハンドラー設定が完了しました
[SettingsStore] メインウィンドウ位置を読み込み: { x: 967, y: 211, width: 400, height: 600 }
[MainWindow] メインウィンドウ作成 - 保存された位置: { x: 967, y: 211, width: 400, height: 600 }
[MainWindow] メインウィンドウ設定: {
  name: 'main',
  width: 400,
  height: 600,
  minWidth: 300,
  minHeight: 400,
  transparent: true,
  frame: false,
  titleBarStyle: 'hiddenInset',
  titleBarOverlay: false,
  thickFrame: false,
  hasShadow: false,
  show: false,
  alwaysOnTop: true,
  webPreferences: {
    preload: '/Users/hirose/dev/mascot/.vite/build/preload.js',
    contextIsolation: true,
    nodeIntegration: false
  },
  position: { x: 967, y: 211 }
}
[WindowManager] Window created and stored: main
[WindowManager] Current windows: [ 'main' ]
[WindowManager] Loading URL for main: http://localhost:3000
[WindowManager] Window created and stored: speechBubble
[WindowManager] Current windows: [ 'main', 'speechBubble' ]
[WindowManager] Loading URL for speechBubble: http://localhost:3000/renderer/speech_bubble/
[WindowManagerController] All windows initialized successfully
[SpeechBubbleWindow] HTMLのロードが完了しました
[MainWindow] メインウィンドウの準備が完了しました
[SpeechBubbleWindow] ウィンドウの準備が完了しました
[MainWindow] Starting optimized titlebar monitoring for main window...
[Main] 起動時動的tools.json生成を開始
[Main] 動的tools.json生成を開始
[Main] 表情フィルタリング詳細:
  - 利用可能表情（重複除去後): []
  - 表情設定: {
  happy: { enabled: true, defaultWeight: 1 },
  sad: { enabled: true, defaultWeight: 1 },
  angry: { enabled: true, defaultWeight: 1 },
  surprised: { enabled: true, defaultWeight: 1 },
  relaxed: { enabled: true, defaultWeight: 1 },
  neutral: { enabled: true, defaultWeight: 1 },
  fun: { enabled: true, defaultWeight: 1 },
  joy: { enabled: true, defaultWeight: 1 },
  sorrow: { enabled: true, defaultWeight: 1 },
  aa: { enabled: true, defaultWeight: 1 },
  ih: { enabled: true, defaultWeight: 1 },
  ou: { enabled: true, defaultWeight: 1 },
  ee: { enabled: true, defaultWeight: 1 },
  oh: { enabled: true, defaultWeight: 1 },
  blink: { enabled: true, defaultWeight: 1 },
  blinkL: { enabled: true, defaultWeight: 1 },
  blinkR: { enabled: true, defaultWeight: 1 }
}
[Main] 有効な表情数: 0
[Main] 有効な表情名: []
[Main] 動的tools.json保存完了: /Users/hirose/dev/mascot/.vite/build/tools.json
[Main] 動的tools.json保存完了: /Users/hirose/dev/mascot/tools.json
[Main] 動的tools.json保存完了: /Users/hirose/dev/mascot/tools.json
[ToolsService] アプリケーションパス: /Users/hirose/dev/mascot
[ToolsService] 作業ディレクトリ: /Users/hirose/dev/mascot
[ToolsService] リソースパス: /Users/hirose/dev/mascot/node_modules/electron/dist/Electron.app/Contents/Resources
[ToolsService] tools.json候補パスをチェック: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] tools.jsonが見つかりました: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] ツールファイルを読み込み中: /Users/hirose/dev/mascot/src/config/tools.json
[ToolsService] 3個のツールが正常に読み込まれました:
  - set_expression: VRMマスコットの表情を設定します。表情を変えることで、マスコットの感情表現を豊かにできます。
  - get_weather_forecast: 指定された都市の現在の天気予報と気温を取得します（デモ用関数）。
  - set_reminder: 指定された時間にリマインダーを設定します（デモ用関数）。
[Main] ToolsService再読み込み完了
Gemini Service を強制再初期化中...
[ToolsService] ツールは既に読み込み済みです
Function Calling用ツールを読み込み: 3 個
構築されたシステムプロンプト: Your role is a desktop mascot named Mascot. You operate on the desktop of a user whose name is User. In all following interactions, you must use the names Mascot (for yourself) and User (for the user) correctly and appropriately. あなたは親しみやすいデスクトップマスコットです。ユーザーとの会話を楽しみ、役立つ情報を提供してください。
Gemini Service が正常に初期化されました（Function Calling対応）
[Main] 起動時動的tools.json生成完了
