<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Chat with Mascot</title>
    <link rel="stylesheet" href="chat.css">
</head>

<body>
    <div id="response-area">
    </div>
    <div id="input-area">
        <textarea id="prompt-input" placeholder="メッセージを入力..." rows="1"></textarea>
        <button id="send-button">送信</button>
        <button id="clear-history-button">履歴削除</button>
    </div>

    <!-- 確認ダイアログ -->
    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <p>本当に会話履歴をすべて削除しますか？<br>この操作は元に戻せません。</p>
            <div class="modal-buttons">
                <button id="confirm-clear" class="modal-button confirm">はい</button>
                <button id="cancel-clear" class="modal-button cancel">いいえ</button>
            </div>
        </div>
    </div>

    <script>
        const promptInput = document.getElementById('prompt-input');
        const sendButton = document.getElementById('send-button');
        const clearHistoryButton = document.getElementById('clear-history-button');
        const responseArea = document.getElementById('response-area');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmClearButton = document.getElementById('confirm-clear');
        const cancelClearButton = document.getElementById('cancel-clear');
        const promptInputStyle = getComputedStyle(promptInput);
        const promptInputPaddingTop = parseFloat(promptInputStyle.paddingTop);
        const promptInputPaddingBottom = parseFloat(promptInputStyle.paddingBottom);
        // CSSで設定したmax-heightを数値で取得 (例: '100px' -> 100)
        // もしCSSでmax-heightを設定していない場合は、ここで適切な最大ピクセル値を設定
        const cssMaxHeight = promptInputStyle.maxHeight;
        let maxTextareaHeightPx = 100; // デフォルトの最大高さ (ピクセル単位)
        if (cssMaxHeight && cssMaxHeight !== 'none') {
            maxTextareaHeightPx = parseFloat(cssMaxHeight);
        } else {
            // CSSにmax-heightがない場合、例えば5行分くらいの高さを設定
            const lineHeight = parseFloat(promptInputStyle.lineHeight) || (parseFloat(promptInputStyle.fontSize) * 1.4);
            maxTextareaHeightPx = (lineHeight * 5) + promptInputPaddingTop + promptInputPaddingBottom;
        }


        promptInput.addEventListener('input', () => {
            promptInput.style.height = 'auto'; // 一旦高さを自動に戻して、内容に応じたscrollHeightを取得
            let newScrollHeight = promptInput.scrollHeight;

            // 上下のpaddingを考慮した実際のコンテンツ高
            // let contentHeight = newScrollHeight - promptInputPaddingTop - promptInputPaddingBottom;
            // scrollHeightはpaddingとborderを含むので、そのまま使って良いことが多いが、
            // box-sizing: border-box; の場合は挙動が変わる。
            // 今回はシンプルにscrollHeightを基準にします。

            if (newScrollHeight > maxTextareaHeightPx) {
                promptInput.style.height = maxTextareaHeightPx + 'px';
                promptInput.style.overflowY = 'auto'; // 最大高さを超えたらスクロールバーを表示
            } else {
                promptInput.style.height = newScrollHeight + 'px';
                promptInput.style.overflowY = 'hidden'; // 最大高さ以下の場合はスクロールバーを隠す
            }
        });

        // 初期ロード時にも一度高さを調整 (プレースホルダーなどで高さが必要な場合のため)
        function initialAdjustTextareaHeight() {
            promptInput.style.height = 'auto';
            let newScrollHeight = promptInput.scrollHeight;
            if (newScrollHeight > maxTextareaHeightPx) {
                promptInput.style.height = maxTextareaHeightPx + 'px';
                promptInput.style.overflowY = 'auto';
            } else {
                // rows="1"やCSSのmin-heightに合わせる
                // ここでは、CSSでmin-heightが設定されていることを期待するか、
                // scrollHeightが初期の1行より小さければ、CSSのmin-heightが効くようにautoのままにするか、
                // 明示的に1行分の高さを設定します。
                // HTMLのrows="1"があるので、初期はCSSのpaddingとline-heightで決まる高さになるはずです。
                // あえてJSで初期高さを設定しなくても良いかもしれません。
                // もし初期表示で高さがおかしい場合は、ここを調整します。
                // 例えば、最初の1行の高さを保つなら:
                // promptInput.style.height = Math.max(parseFloat(promptInputStyle.minHeight) || 0, newScrollHeight) + 'px';
                // 今回は input イベントで動的に変わるので、初期のoverflowYだけ設定しておきます。
                if (newScrollHeight <= maxTextareaHeightPx) {
                    promptInput.style.overflowY = 'hidden';
                } else {
                    promptInput.style.overflowY = 'auto';
                }
            }
        }
        initialAdjustTextareaHeight(); // 読み込み時に一度実行
        // --- ↑ テキストエリアの高さ自動調整ここまで ↑ ---
        // --- メッセージを応答エリアに追加する関数 ---
        function addMessageToResponseArea(messageText, senderType) { // senderType は 'user' または 'mascot'
            const p = document.createElement('p');
            p.textContent = messageText; // メッセージ本文だけを設定

            if (senderType === 'user') {
                p.classList.add('user-message');
            } else if (senderType === 'mascot') {
                p.classList.add('mascot-message');
            }
            responseArea.appendChild(p);
            responseArea.scrollTop = responseArea.scrollHeight; // 自動スクロール
        }

        // --- Enterキーでも送信できるように ---
            promptInput.addEventListener('keydown', function (event) { // 'keypress' から 'keydown' に変更するとShiftキーの状態をより確実に拾えます
                if (event.key === 'Enter') {
                    if (!event.shiftKey) { // Shiftキーが押されていない時だけ送信
                        event.preventDefault(); // textareaでのデフォルトの改行を防ぐ
                        sendButton.click();     // 送信ボタンのクリックイベントを発火
                    }
                    // Shiftキーが押されている時は、通常の改行が行われます
                }
            });

        // --- 履歴の読み込みと表示 ---
        async function loadChatHistory() {
            try {
                if (window.electronAPI && window.electronAPI.getChatHistory) {
                    const history = await window.electronAPI.getChatHistory();
                    for (const message of history) {
                        if (message.role === 'user') {
                            addMessageToResponseArea(message.content, 'user');
                        } else if (message.role === 'assistant') {
                            addMessageToResponseArea(message.content, 'mascot');
                        }
                    }
                }
            } catch (error) {
                console.error('履歴の読み込みエラー:', error);
            }
        }

        // --- ページ読み込み時に履歴を表示 ---
        window.addEventListener('DOMContentLoaded', () => {
            loadChatHistory();
        });

        // --- 送信ボタンのクリック処理（履歴機能付き） ---
        sendButton.addEventListener('click', async () => {
            const prompt = promptInput.value;
            if (!prompt.trim()) return;

            addMessageToResponseArea(prompt, 'user'); // ★メッセージ本文とタイプ 'user' を渡す
            promptInput.value = ''; // 入力欄クリア

            if (window.electronAPI && window.electronAPI.sendChatMessage) {
                try {
                    const response = await window.electronAPI.sendChatMessage(prompt);
                    addMessageToResponseArea(response, 'mascot'); // ★返答本文とタイプ 'mascot' を渡す
                } catch (error) {
                    console.error('Error sending chat message:', error);
                    const errorMessage = (error instanceof Error) ? error.message : String(error);
                    addMessageToResponseArea('エラー: ' + errorMessage, 'mascot');
                }
            } else {
                console.error('electronAPI or sendChatMessage is not available.');
                addMessageToResponseArea('エラー: メインプロセスに接続できません。', 'mascot');
            }
        });

        // --- 履歴削除機能 ---
        clearHistoryButton.addEventListener('click', () => {
            confirmationModal.style.display = 'block';
        });

        confirmClearButton.addEventListener('click', async () => {
            try {
                if (window.electronAPI && window.electronAPI.clearChatHistory) {
                    const result = await window.electronAPI.clearChatHistory();
                    if (result.success) {
                        responseArea.innerHTML = ''; // UIの履歴もクリア
                        confirmationModal.style.display = 'none';
                    } else {
                        console.error('履歴削除エラー:', result.error);
                        addMessageToResponseArea('エラー: 履歴の削除に失敗しました。', 'mascot');
                    }
                }
            } catch (error) {
                console.error('履歴削除エラー:', error);
                addMessageToResponseArea('エラー: 履歴の削除に失敗しました。', 'mascot');
            }
            confirmationModal.style.display = 'none';
        });

        cancelClearButton.addEventListener('click', () => {
            confirmationModal.style.display = 'none';
        });

        // モーダルの外側をクリックしても閉じる
        confirmationModal.addEventListener('click', (event) => {
            if (event.target === confirmationModal) {
                confirmationModal.style.display = 'none';
            }
        });
    </script>
</body>

</html>